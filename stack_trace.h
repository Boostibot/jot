#include "string.h"

namespace jot
{
    struct Stack_Trace_Entry
    {
        //Data: if the value is its default value (0, -1 or "") then
        // it was not obtained.
        usize address = 0;
        isize source_line = -1;
        String_Builder source_file;
        String_Builder source_function;
        String_Builder source_mangled_function;
        String_Builder source_module;
        String_Builder source_module_name;

        //if is generated by the runtime (ie msvc CxxThrowException, RaiseException etc)
        // or functions before main
        bool is_architectural = false;
    };

    struct Stack_Tracer
    {
        //captures the stack trace at the place of the call site
        virtual Array<Stack_Trace_Entry> capture_stack_trace(isize skip_levels = 0, isize max_levels = -1) = 0; 

        //Calls protected_fn with the given protected_context. 
        //If protected_fn completes and no exception occurs returns true. 
        //If an exception occurs generates a trace from said exception and calls fallback_fn with its
        // context, gathered stack trace and returns false.
        //
        //@NOTE: If you want to switch on the type of the expression include a try-catch block for each desired type
        // inside the protected_fn and then rethrow so that the exception gets properly handled and backtrace gets generated
        //
        //@NOTE: to call this function use the free function version below that also accepts lambdas
        virtual bool protected_call(
            void (*protected_fn)(void* p_context), void* protected_context, 
            void (*fallback_fn)(void* f_context, Array<Stack_Trace_Entry> trace), void* fallback_context
        ) = 0;

        virtual ~Stack_Tracer() noexcept {}
    };
    
    //Marks all traces from the specified file as architectural. This is useful for files such as this one which should
    // be transparent as far as stack trace is concerned
    static void mark_traces_from_file_as_archutectural(Array<Stack_Trace_Entry>* traces, String file)
    {
        //Mark all traces from this file as architectural
        for(Stack_Trace_Entry& trace : *traces)
        {
            String trace_file = slice(trace.source_file);
            isize index = first_index_of(trace_file, file);

            //if was found and is at end of the string
            if(index != -1 && index + file.size == trace_file.size) 
                trace.is_architectural = true;
        }
    }

    template<typename Portected_Fn, typename Fallback_Fn>
    bool protected_call(Stack_Tracer* tracer, Portected_Fn protected_fn, Fallback_Fn fallback_fn)
    {
        struct local_fn
        {
            static void protected_adaptor(void* args)
            {
                Portected_Fn& fn = *(Portected_Fn*) args;
                fn();
            }
            
            static void fallback_adaptor(void* args, Array<Stack_Trace_Entry> trace)
            {
                mark_traces_from_file_as_archutectural(&trace, "stack_trace.h");
                Fallback_Fn& fn = *(Fallback_Fn*) args;
                fn(move(&trace));
            }
        };

        bool ret = tracer->protected_call(
            local_fn::protected_adaptor, &protected_fn,
            local_fn::fallback_adaptor, &fallback_fn
        );

        return ret;
    }

}